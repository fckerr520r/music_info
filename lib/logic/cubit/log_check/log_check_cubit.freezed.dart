// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'log_check_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$UserCheckStateTearOff {
  const _$UserCheckStateTearOff();

  _UserCheckLoadingState loading() {
    return const _UserCheckLoadingState();
  }

  _UserCheckLoggedState logged() {
    return const _UserCheckLoggedState();
  }

  _UserCheckNotLoggedState notLogged() {
    return const _UserCheckNotLoggedState();
  }
}

/// @nodoc
const $UserCheckState = _$UserCheckStateTearOff();

/// @nodoc
mixin _$UserCheckState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() logged,
    required TResult Function() notLogged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? notLogged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? notLogged,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UserCheckLoadingState value) loading,
    required TResult Function(_UserCheckLoggedState value) logged,
    required TResult Function(_UserCheckNotLoggedState value) notLogged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_UserCheckLoadingState value)? loading,
    TResult Function(_UserCheckLoggedState value)? logged,
    TResult Function(_UserCheckNotLoggedState value)? notLogged,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UserCheckLoadingState value)? loading,
    TResult Function(_UserCheckLoggedState value)? logged,
    TResult Function(_UserCheckNotLoggedState value)? notLogged,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UserCheckStateCopyWith<$Res> {
  factory $UserCheckStateCopyWith(
          UserCheckState value, $Res Function(UserCheckState) then) =
      _$UserCheckStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$UserCheckStateCopyWithImpl<$Res>
    implements $UserCheckStateCopyWith<$Res> {
  _$UserCheckStateCopyWithImpl(this._value, this._then);

  final UserCheckState _value;
  // ignore: unused_field
  final $Res Function(UserCheckState) _then;
}

/// @nodoc
abstract class _$UserCheckLoadingStateCopyWith<$Res> {
  factory _$UserCheckLoadingStateCopyWith(_UserCheckLoadingState value,
          $Res Function(_UserCheckLoadingState) then) =
      __$UserCheckLoadingStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$UserCheckLoadingStateCopyWithImpl<$Res>
    extends _$UserCheckStateCopyWithImpl<$Res>
    implements _$UserCheckLoadingStateCopyWith<$Res> {
  __$UserCheckLoadingStateCopyWithImpl(_UserCheckLoadingState _value,
      $Res Function(_UserCheckLoadingState) _then)
      : super(_value, (v) => _then(v as _UserCheckLoadingState));

  @override
  _UserCheckLoadingState get _value => super._value as _UserCheckLoadingState;
}

/// @nodoc

class _$_UserCheckLoadingState implements _UserCheckLoadingState {
  const _$_UserCheckLoadingState();

  @override
  String toString() {
    return 'UserCheckState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _UserCheckLoadingState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() logged,
    required TResult Function() notLogged,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? notLogged,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? notLogged,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UserCheckLoadingState value) loading,
    required TResult Function(_UserCheckLoggedState value) logged,
    required TResult Function(_UserCheckNotLoggedState value) notLogged,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_UserCheckLoadingState value)? loading,
    TResult Function(_UserCheckLoggedState value)? logged,
    TResult Function(_UserCheckNotLoggedState value)? notLogged,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UserCheckLoadingState value)? loading,
    TResult Function(_UserCheckLoggedState value)? logged,
    TResult Function(_UserCheckNotLoggedState value)? notLogged,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _UserCheckLoadingState implements UserCheckState {
  const factory _UserCheckLoadingState() = _$_UserCheckLoadingState;
}

/// @nodoc
abstract class _$UserCheckLoggedStateCopyWith<$Res> {
  factory _$UserCheckLoggedStateCopyWith(_UserCheckLoggedState value,
          $Res Function(_UserCheckLoggedState) then) =
      __$UserCheckLoggedStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$UserCheckLoggedStateCopyWithImpl<$Res>
    extends _$UserCheckStateCopyWithImpl<$Res>
    implements _$UserCheckLoggedStateCopyWith<$Res> {
  __$UserCheckLoggedStateCopyWithImpl(
      _UserCheckLoggedState _value, $Res Function(_UserCheckLoggedState) _then)
      : super(_value, (v) => _then(v as _UserCheckLoggedState));

  @override
  _UserCheckLoggedState get _value => super._value as _UserCheckLoggedState;
}

/// @nodoc

class _$_UserCheckLoggedState implements _UserCheckLoggedState {
  const _$_UserCheckLoggedState();

  @override
  String toString() {
    return 'UserCheckState.logged()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _UserCheckLoggedState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() logged,
    required TResult Function() notLogged,
  }) {
    return logged();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? notLogged,
  }) {
    return logged?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? notLogged,
    required TResult orElse(),
  }) {
    if (logged != null) {
      return logged();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UserCheckLoadingState value) loading,
    required TResult Function(_UserCheckLoggedState value) logged,
    required TResult Function(_UserCheckNotLoggedState value) notLogged,
  }) {
    return logged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_UserCheckLoadingState value)? loading,
    TResult Function(_UserCheckLoggedState value)? logged,
    TResult Function(_UserCheckNotLoggedState value)? notLogged,
  }) {
    return logged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UserCheckLoadingState value)? loading,
    TResult Function(_UserCheckLoggedState value)? logged,
    TResult Function(_UserCheckNotLoggedState value)? notLogged,
    required TResult orElse(),
  }) {
    if (logged != null) {
      return logged(this);
    }
    return orElse();
  }
}

abstract class _UserCheckLoggedState implements UserCheckState {
  const factory _UserCheckLoggedState() = _$_UserCheckLoggedState;
}

/// @nodoc
abstract class _$UserCheckNotLoggedStateCopyWith<$Res> {
  factory _$UserCheckNotLoggedStateCopyWith(_UserCheckNotLoggedState value,
          $Res Function(_UserCheckNotLoggedState) then) =
      __$UserCheckNotLoggedStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$UserCheckNotLoggedStateCopyWithImpl<$Res>
    extends _$UserCheckStateCopyWithImpl<$Res>
    implements _$UserCheckNotLoggedStateCopyWith<$Res> {
  __$UserCheckNotLoggedStateCopyWithImpl(_UserCheckNotLoggedState _value,
      $Res Function(_UserCheckNotLoggedState) _then)
      : super(_value, (v) => _then(v as _UserCheckNotLoggedState));

  @override
  _UserCheckNotLoggedState get _value =>
      super._value as _UserCheckNotLoggedState;
}

/// @nodoc

class _$_UserCheckNotLoggedState implements _UserCheckNotLoggedState {
  const _$_UserCheckNotLoggedState();

  @override
  String toString() {
    return 'UserCheckState.notLogged()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _UserCheckNotLoggedState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function() logged,
    required TResult Function() notLogged,
  }) {
    return notLogged();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? notLogged,
  }) {
    return notLogged?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function()? logged,
    TResult Function()? notLogged,
    required TResult orElse(),
  }) {
    if (notLogged != null) {
      return notLogged();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UserCheckLoadingState value) loading,
    required TResult Function(_UserCheckLoggedState value) logged,
    required TResult Function(_UserCheckNotLoggedState value) notLogged,
  }) {
    return notLogged(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_UserCheckLoadingState value)? loading,
    TResult Function(_UserCheckLoggedState value)? logged,
    TResult Function(_UserCheckNotLoggedState value)? notLogged,
  }) {
    return notLogged?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UserCheckLoadingState value)? loading,
    TResult Function(_UserCheckLoggedState value)? logged,
    TResult Function(_UserCheckNotLoggedState value)? notLogged,
    required TResult orElse(),
  }) {
    if (notLogged != null) {
      return notLogged(this);
    }
    return orElse();
  }
}

abstract class _UserCheckNotLoggedState implements UserCheckState {
  const factory _UserCheckNotLoggedState() = _$_UserCheckNotLoggedState;
}
